---
title: LeetCode-15-三数之和 | 哈希表7
date: 2024/03/11
categories:
 - 算法
---
## 15. 三数之和
给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
 

示例 1：
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```
示例 2：
```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```
示例 3：
```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

提示：
```
3 <= nums.length <= 3000
-10^5 <= nums[i] <= 10^5
```

## 解题思路
从要寻找符合条件的元素这一角度上，本题可以用哈希表来解，但是题目要求三元组不能重复（不是元素值不能重复、是这几个数值的组合不能重复），如果使用哈希表就很难处理去重的细节。

本题无需记录/返回下标，因此可以对数组进行排序，使用双指针解法：
1. 对数组进行从小到大的排序。
2. 三元组，第一个元素下标`i`用for循环确定，后两个元素用双指针。
3. 左指针`left`从下标`i+1`处开始向右移动（记作`j`），右指针`right`从下标`nums.length-1`开始向左移动（记作`k`）。
4. 指针何时移动？
    a. 三元素和大于0时，右指针移动、和变小
    b. 三元素和小于0时，左指针移动、和变大
    c. 三元素和等于0时，左右指针同时移动、寻找下一个符合条件的三元组
5. 怎么实现去重？
    - 在移动第一个元素的时候需要去重！
        第一个元素不能与旧值相等
    - 在找到一个符合条件的三元组后需要去重！
        a. 左指针移动时：移动时先排除左指针的值重复的情况（），由于数组已经排序，只要对比左指针新位置和旧位置的元素值即可。如果新位置和旧位置的值一致，那么第一个元素、第二个元素都和上一个三元组一致，符合条件的第三个元素也会与上一个三元组一致，三元组就重复了。排除第二个元素一致的情况，即可去重。
        b. 右指针移动时：与左指针同理
6. 怎么剪枝？
    如果第一元素大于0，由于数组元素已经从小到大排序，那么三元素都大于0、三元组和肯定大于0，不可能得到符合条件的三元组，该情况可以剪枝。且第一元素是从左到右、从小到大，之后的第一元素也都大于0，可以直接结束所有的寻找（`break`）。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);

        List<List<Integer>> ret = new ArrayList<>();
        for (int i = 0; i< nums.length; i++) {
            if (nums[i] > 0) break;
            if (i != 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            int l = i + 1, r = nums.length - 1;
            while (l < r) {
                int sum = nums[i] + nums[l] + nums[r];

                if (sum > 0) {
                    r --;
                } else if (sum < 0) {
                    l ++;
                } else {
                    ret.add(Arrays.asList(nums[i], nums[l], nums[r]));
                    
                    // 对nums[l]和nums[r]去重
                    while (l < r && nums[l] == nums[l + 1]) {
                        l ++;
                    }
                    while (l < r && nums[r] == nums[r - 1]) {
                        r --;
                    }
                    l ++;
                    r --;
                }
            }
        }

        return ret;
    }
}
```