import{_ as n,r as c,o as t,c as d,a as e,b as a,d as s,e as i}from"./app-Nu3yXL5S.js";const r="/image/2024091303.png",l="/image/2024091302.png",p={},h={class:"custom-container info"},u=e("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[e("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[e("circle",{cx:"12",cy:"12",r:"9"}),e("path",{d:"M12 8h.01"}),e("path",{d:"M11 12h1v4h1"})])],-1),x=e("p",{class:"custom-container-title"},"INFO",-1),b={href:"http://t.csdnimg.cn/KWwAV",target:"_blank",rel:"noopener noreferrer"},w=i(`<h2 id="为什么要用树状数组" tabindex="-1"><a class="header-anchor" href="#为什么要用树状数组" aria-hidden="true">#</a> 为什么要用树状数组</h2><p>树状数组可以解决的问题：</p><ol><li>单点修改，区间查询</li><li>区间修改，单点查询（差分后）</li></ol><h2 id="怎么用树状数组" tabindex="-1"><a class="header-anchor" href="#怎么用树状数组" aria-hidden="true">#</a> 怎么用树状数组</h2><h3 id="前置知识" tabindex="-1"><a class="header-anchor" href="#前置知识" aria-hidden="true">#</a> 前置知识</h3><h4 id="lowbit-x" tabindex="-1"><a class="header-anchor" href="#lowbit-x" aria-hidden="true">#</a> lowbit(x)</h4><p><code>lowbit(x)</code>即为x转为二进制后最低位1代表的数值，例如：<code>lowbit(5D) = lowbit(101B) = 1B = 1D</code>、<code>lowbit(6D) = lowbit(110B) = 10B = 2D</code>。计算方法为<code>x &amp; (-x)</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="树状数组结构" tabindex="-1"><a class="header-anchor" href="#树状数组结构" aria-hidden="true">#</a> 树状数组结构</h4><p><code>t[x]</code>保存以x为根的子树中叶节点值的和。<br><code>x+lowbit(x)</code>即为绿色箭头，可以找到自己的父亲节点；<code>x-lowbit(x)</code>即为蓝色箭头，重复到不可重复时可找到区间[1, x]的元素和所需的所有<code>t[x]</code>。（具体举例见下） <img src="`+r+'" alt=""></p><h3 id="单点修改-区间查询" tabindex="-1"><a class="header-anchor" href="#单点修改-区间查询" aria-hidden="true">#</a> 单点修改，区间查询</h3><p><code>a[]</code>是一个数字数组，而<code>t[]</code>是从<code>a[]</code>构造的树形数组。 <img src="'+l+'" alt=""></p><p>单点修改举例：把<code>a[1]</code>的值加1，更新<code>t[]</code><br><code>t[1] += 1</code> --1+lowbit(1)=2--&gt; <code>t[2] += 1</code> --2+lowbit(2)=4--&gt; <code>t[4] += 1</code> --4+lowbit(4)=8--&gt; <code>t[8] += 1</code></p><p>区间查询举例：查询<code>a[1]</code>~<code>a[7]</code>的元素和<br><code>ans += t[7]</code> --7-lowbit(7)=6--&gt; <code>ans += t[6]</code> --6-lowbit(6)=4--&gt; <code>ans += t[6]</code></p><h3 id="区间修改-单点查询-差分后" tabindex="-1"><a class="header-anchor" href="#区间修改-单点查询-差分后" aria-hidden="true">#</a> 区间修改，单点查询（差分后）</h3><p>先求得<code>a[]</code>的差分数组<code>c[]</code>，在<code>c[]</code>上构造树形数组<code>t[]</code>。</p><ul><li>对<code>a[]</code>的区间修改 == 对<code>c[]</code>的单点修改 / 给a[3]~a[5]的元素都加一 == c[3]+=1、c[6]-=1</li><li>对<code>a[]</code>的单点查询 == 对<code>c[]</code>的区间查询 / 查询a[3] == 查询c[1]~c[3]的元素和</li></ul>',17);function _(k,m){const o=c("ExternalLinkIcon");return t(),d("div",null,[e("div",h,[u,x,e("p",null,[a("推荐阅读"),e("a",b,[a("树状数组(详细分析+应用)，看不懂打死我!"),s(o)])])]),w])}const v=n(p,[["render",_],["__file","binary-indexed-tree.html.vue"]]);export{v as default};
