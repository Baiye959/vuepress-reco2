import{_ as c,r as i,o as s,c as n,a as e,d as t,w as d,b as o,e as a}from"./app-uEzlI9sK.js";const h={},r={class:"custom-container tip"},u=e("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[e("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[e("circle",{cx:"12",cy:"12",r:"9"}),e("path",{d:"M12 8h.01"}),e("path",{d:"M11 12h1v4h1"})])],-1),p=e("p",{class:"custom-container-title"},"TIP",-1),m=e("p",null,[e("b",null,"哈希表用来快速判断一个元素是否出现在集合里")],-1),_=e("br",null,null,-1),g=e("br",null,null,-1),b=e("br",null,null,-1),f=e("br",null,null,-1),M=e("br",null,null,-1),S=e("br",null,null,-1),H=e("br",null,null,-1),k=a('<h2 id="哈希表理论基础" tabindex="-1"><a class="header-anchor" href="#哈希表理论基础" aria-hidden="true">#</a> 哈希表理论基础</h2><p>对于哈希表，要知道哈希函数和哈希碰撞在哈希表中的作用。</p><ul><li>哈希函数：把传入的key映射到符号表的索引上。</li><li>哈希碰撞：处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。</li></ul><p>接下来是常见的三种哈希结构：</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><h2 id="哈希表三种结构在题目中的使用选择" tabindex="-1"><a class="header-anchor" href="#哈希表三种结构在题目中的使用选择" aria-hidden="true">#</a> 哈希表三种结构在题目中的使用选择</h2><h3 id="数组作为哈希表" tabindex="-1"><a class="header-anchor" href="#数组作为哈希表" aria-hidden="true">#</a> 数组作为哈希表</h3><p>数组是最简单的哈希表，适合题目中元素范围确定、较小且连续的，原因如下：</p><ul><li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li><li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li></ul><p>题目举例：</p>',10),x=e("h3",{id:"set-集合-作为哈希表",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#set-集合-作为哈希表","aria-hidden":"true"},"#"),o(" set（集合）作为哈希表")],-1),y=e("p",null,"需存元素范围不确定/元素分散/元素范围较大，且只需存一种值时，用set结构",-1),C=e("p",null,"题目举例：",-1),w=a('<p>Java中实现Set接口的类：</p><ol><li>HashSet <code>HashSet</code> 是 <code>Set</code> 接口的典型实现之一，它基于哈希表实现。哈希表可以实现快速的插入、删除和查找操作，因此 <code>HashSet</code> 的性能非常高。但是，在使用 <code>HashSet</code> 时需要注意元素的顺序是不确定的。</li><li>LinkedHashSet <code>LinkedHashSet</code> 是 <code>HashSet</code> 的升级版，它不仅可以保证元素不重复，还可以按照插入的顺序来保存元素。<code>LinkedHashSet</code> 内部维护了一个双向链表来维护元素的插入顺序，因此，在使用 <code>LinkedHashSet</code> 时，元素的顺序就可以保证。</li><li>TreeSet <code>TreeSet</code> 是基于红黑树实现的 <code>Set</code> 集合，可以保证元素有序，且插入、删除、查询等操作均为 <code>O(logn)</code> 的时间复杂度。但是，由于红黑树的实现原理，要求元素必须实现 <code>Comparable</code> 接口或者在创建 <code>TreeSet</code> 时传入一个 <code>Comparator</code> 对象才能进行排序。</li><li>EnumSet <code>EnumSet</code> 是一个专门为枚举类型设计的 <code>Set</code> 集合，它是一种非常高效的 <code>Set</code> 实现方式。由于枚举类型的值是有限的且预定义的，因此 <code>EnumSet</code> 内部使用一个位向量（bit vector）来存储元素，从而可以实现高效的插入、删除和查询操作。</li><li>CopyOnWriteArraySet <code>CopyOnWriteArraySet</code> 是一个线程安全的 <code>Set</code> 集合，它是基于 Copy-On-Write（写时复制）技术实现的。当对集合进行修改操作时，<code>CopyOnWriteArraySet</code> 会复制一个新的数组，并在新的数组中进行修改，待修改完成后再将原数组引用指向新的数组，从而保证了修改操作的线程安全性。但是，由于每次修改时都需要复制一个新的数组，因此 <code>CopyOnWriteArraySet</code> 的性能不如其他 <code>Set</code> 实现类。</li></ol><h3 id="map-映射-作为哈希表" tabindex="-1"><a class="header-anchor" href="#map-映射-作为哈希表" aria-hidden="true">#</a> map（映射）作为哈希表</h3><p>需存元素范围不确定/元素分散/元素范围较大，且要存一对值时，用map结构</p><p>题目举例：</p>',5),v=a('<p>Java中实现Map接口的类：</p><ol><li>HashMap（目前只用过这个） <code>HashMap</code> 是最常用的Map，根据键的HashCode值存储数据，可以根据键直接获取它的值，具有很快的访问速度，遍历时候的顺序是完全随机的。<code>HashMap</code>只允许一个键为<code>Null</code>,允许多个值为<code>Null</code>； <ul><li>特性： 完全随机</li><li>优点： 随机访问，取值速度快</li><li>缺点： 多个线程同时写<code>HashMap</code>可能导致数据不一致，如果需要同步，使用<code>Collection</code>的<code>synchronizedMap</code>方法或者使用<code>ConcurrentHashMap</code></li></ul></li><li>LinkedHashMap <code>LinkedHashMap</code> 是<code>HashMap</code>的一个子类，保存了记录的插入顺序，与<code>HashMap</code>的随机遍历不同，在用<code>Iterator</code>遍历的时候，先得到的记录肯定是先插入的，类似于python中的<code>OrderedDict</code>。遍历速度会比<code>HashMap</code>慢，不过有一种情况例外： 当<code>HashMap</code>的容量很大，实际数据很少时 ， 因为<code>HashMap</code>的遍历速度和它的容量有关，而<code>LinkedHashMap</code>只跟实际数据量有关。</li><li>TreeMap <code>TreeMap</code>实现<code>SortMap</code>接口，能够将它保存的记录按键排序，默认是按键的升序排列，也可以指定排序的比较器，遍历<code>TreeMap</code>的时候，得到的记录是按照键排过序的。</li><li>根据数据选择Map 一般情况下，用的最多的是<code>HashMap</code>，在 Map 中插入、删除和定位元素，<code>HashMap</code> 是最好的选择。但如果要按自然顺序或自定义顺序遍历键，那么<code>TreeMap</code>会更好。如果需要输出的顺序和输入的相同，那么用 <code>LinkedHashMap</code> 可以实现，它还可以按读取顺序来排列。</li></ol><p>为什么不能都用map结构？<br> ——使用map的空间消耗更大，因为map要维护红黑树或者符号表、要做哈希函数的运算。</p><h2 id="不适合使用哈希表来解题的情况" tabindex="-1"><a class="header-anchor" href="#不适合使用哈希表来解题的情况" aria-hidden="true">#</a> 不适合使用哈希表来解题的情况</h2><p>题目中要求对组合情况进行去重，而不是对元素进行去重，使用哈希表时去重细节较多、易出错。</p><p>题目举例：</p>',6);function L(T,$){const l=i("RouterLink");return s(),n("div",null,[e("div",r,[u,p,m,e("p",null,[t(l,{to:"/blogs/algorithm/leetcode242.html"},{default:d(()=>[o("242.有效的字母异位词")]),_:1}),_,t(l,{to:"/blogs/algorithm/leetcode349.html"},{default:d(()=>[o("349.两个数组的交集")]),_:1}),g,t(l,{to:"/blogs/algorithm/leetcode202.html"},{default:d(()=>[o("202.快乐数")]),_:1}),b,t(l,{to:"/blogs/algorithm/leetcode1.html"},{default:d(()=>[o("1.两数之和")]),_:1}),f,t(l,{to:"/blogs/algorithm/leetcode454.html"},{default:d(()=>[o("454.四数相加II")]),_:1}),M,t(l,{to:"/blogs/algorithm/leetcode383.html"},{default:d(()=>[o("383.赎金信")]),_:1}),S,t(l,{to:"/blogs/algorithm/leetcode15.html"},{default:d(()=>[o("15.三数之和")]),_:1}),H,t(l,{to:"/blogs/algorithm/leetcode18.html"},{default:d(()=>[o("18.四数之和")]),_:1})])]),k,e("ul",null,[e("li",null,[t(l,{to:"/blogs/algorithm/leetcode242.html"},{default:d(()=>[o("242.有效的字母异位词")]),_:1}),o("：只包含小写字母")]),e("li",null,[t(l,{to:"/blogs/algorithm/leetcode383.html"},{default:d(()=>[o("383.赎金信")]),_:1}),o("：只包含小写字母")]),e("li",null,[t(l,{to:"/blogs/algorithm/leetcode349.html"},{default:d(()=>[o("349.两个数组的交集")]),_:1}),o("：$ 0 <= nums1[i], nums2[i] <= 1000 $")])]),x,y,C,e("ul",null,[e("li",null,[t(l,{to:"/blogs/algorithm/leetcode202.html"},{default:d(()=>[o("202.快乐数")]),_:1}),o("：$ 1 <= n <= 2^31 - 1 $，存数")])]),w,e("ul",null,[e("li",null,[t(l,{to:"/blogs/algorithm/leetcode1.html"},{default:d(()=>[o("1.两数之和")]),_:1}),o("：$ -10^9 <= nums[i] <= 10^9 $，存（值，次数）")]),e("li",null,[t(l,{to:"/blogs/algorithm/leetcode454.html"},{default:d(()=>[o("454.四数相加II")]),_:1}),o("：$ -2^28 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 2^28 $，存(和, 次数)")])]),v,e("ul",null,[e("li",null,[t(l,{to:"/blogs/algorithm/leetcode15.html"},{default:d(()=>[o("15.三数之和")]),_:1}),o("：对三元组去重")]),e("li",null,[t(l,{to:"/blogs/algorithm/leetcode18.html"},{default:d(()=>[o("18.四数之和")]),_:1}),o("：对四元组去重")])])])}const I=c(h,[["render",L],["__file","hash.html.vue"]]);export{I as default};
