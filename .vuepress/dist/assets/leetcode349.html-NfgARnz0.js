import{_ as n,o as s,c as a,e}from"./app-er98NrFX.js";const t={},p=e(`<h2 id="_349-两个数组的交集" tabindex="-1"><a class="header-anchor" href="#_349-两个数组的交集" aria-hidden="true">#</a> 349. 两个数组的交集</h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <b>它们的交集</b> 。输出结果中的每个元素一定是 <b>唯一</b> 的。我们可以 <b>不考虑输出结果的顺序</b> 。</p><p>示例 1：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 2：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1 &lt;= nums1.length, nums2.length &lt;= 1000
0 &lt;= nums1[i], nums2[i] &lt;= 1000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="java基础补充" tabindex="-1"><a class="header-anchor" href="#java基础补充" aria-hidden="true">#</a> java基础补充</h2><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h3><p>在 Java 的 <code>Collection</code> 框架中，有多个实现 <code>Set</code> 接口的类，常用的有以下几种：</p><ol><li><p>HashSet <br><code>HashSet</code> 是 <code>Set</code> 接口的典型实现之一，它基于哈希表实现。哈希表可以实现快速的插入、删除和查找操作，因此 <code>HashSet</code> 的性能非常高。但是，在使用 <code>HashSet</code> 时需要注意元素的顺序是不确定的。</p></li><li><p>LinkedHashSet <br><code>LinkedHashSet</code> 是 <code>HashSet</code> 的升级版，它不仅可以保证元素不重复，还可以按照插入的顺序来保存元素。<code>LinkedHashSet</code> 内部维护了一个双向链表来维护元素的插入顺序，因此，在使用 <code>LinkedHashSet</code> 时，元素的顺序就可以保证。</p></li><li><p>TreeSet <br><code>TreeSet</code> 是基于红黑树实现的 <code>Set</code> 集合，可以保证元素有序，且插入、删除、查询等操作均为 <code>O(logn)</code> 的时间复杂度。但是，由于红黑树的实现原理，要求元素必须实现 <code>Comparable</code> 接口或者在创建 <code>TreeSet</code> 时传入一个 <code>Comparator</code> 对象才能进行排序。</p></li><li><p>EnumSet <br><code>EnumSet</code> 是一个专门为枚举类型设计的 <code>Set</code> 集合，它是一种非常高效的 <code>Set</code> 实现方式。由于枚举类型的值是有限的且预定义的，因此 <code>EnumSet</code> 内部使用一个位向量（bit vector）来存储元素，从而可以实现高效的插入、删除和查询操作。</p></li><li><p>CopyOnWriteArraySet <br><code>CopyOnWriteArraySet</code> 是一个线程安全的 <code>Set</code> 集合，它是基于 Copy-On-Write（写时复制）技术实现的。当对集合进行修改操作时，<code>CopyOnWriteArraySet</code> 会复制一个新的数组，并在新的数组中进行修改，待修改完成后再将原数组引用指向新的数组，从而保证了修改操作的线程安全性。但是，由于每次修改时都需要复制一个新的数组，因此 <code>CopyOnWriteArraySet</code> 的性能不如其他 <code>Set</code> 实现类。</p></li></ol><h3 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist" aria-hidden="true">#</a> ArrayList</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span> <span class="token comment">// 引入 ArrayList 类</span>

<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> objectName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　 <span class="token comment">// 初始化</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><p>这道题跟上道题一样，值的范围小（0 &lt;= nums1[i], nums2[i] &lt;= 1000），适合用数组进行求解。<br> 如果题目没有给出值的范围、或者值的范围较大，就适合用set求解。<br> 为了熟悉各种解法，也写一下用set的解法。这道题不需要元素按顺序排列，用<code>HashSet</code>就可以了。</p><h3 id="解法一-set" tabindex="-1"><a class="header-anchor" href="#解法一-set" aria-hidden="true">#</a> 解法一（set）</h3><p>先将数组1里的元素放到哈希表里，再遍历数组2，如果数组2中元素也在哈希表中存在，就加入最终的交集中。<br> 有一点要注意，因为题目要求输出结果中的每个元素一定是 <b>唯一</b> 的，所以在数组1元素放入哈希表时要去重，由于是用<code>HashSet</code>，会自动去重，就不用手动判断直接加入了。</p><p>由于java中无法创建不定长数组，这里先用一个set存交集，最后再转成数组（这里有两种方法，一种直接将结果集合转为数组、一种是另外申请一个数组存放结果）。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">intersection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> set1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> retSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            set1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>set1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                retSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//方法1：将结果集合转为数组</span>
        <span class="token keyword">return</span> retSet<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span>x <span class="token operator">-&gt;</span> x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// //方法2：另外申请一个数组存放retSet中的元素,最后返回数组</span>
        <span class="token comment">// int[] ret = new int[retSet.size()];</span>
        <span class="token comment">// int j = 0;</span>
        <span class="token comment">// for(int i : retSet){</span>
        <span class="token comment">//     ret[j++] = i;</span>
        <span class="token comment">// }</span>
        
        <span class="token comment">// return ret;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="解法二-数组" tabindex="-1"><a class="header-anchor" href="#解法二-数组" aria-hidden="true">#</a> 解法二（数组）</h3><p>分别用长度为1001的数组记录两个数组中出现的值（让以该值为下标的元素值加一），最后遍历、两个数组中都出现的值就加入结果集合。</p><p>尝试用一下<code>ArrayList</code>（可动态修改的数组——这个数组不能用于返回、类型不一样）存结果。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">intersection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hash1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1001</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hash2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1001</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            hash1<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            hash2<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> retArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">1001</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>hash1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> hash2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                retArray<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ret<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>retArray<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> retArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ret<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,24),o=[p];function c(i,l){return s(),a("div",null,o)}const r=n(t,[["render",c],["__file","leetcode349.html.vue"]]);export{r as default};
