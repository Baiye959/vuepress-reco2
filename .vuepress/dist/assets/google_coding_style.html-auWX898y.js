import{_ as t,r as i,o as c,c as r,a,d as n,b as s,e as o}from"./app-sZn_pEP8.js";const l={},p={class:"custom-container info"},d=a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8h.01"}),a("path",{d:"M11 12h1v4h1"})])],-1),h=a("p",{class:"custom-container-title"},"INFO",-1),u=a("br",null,null,-1),k={href:"https://google.github.io/styleguide/javaguide.html",target:"_blank",rel:"noopener noreferrer"},_=a("br",null,null,-1),m={href:"https://hawstein.com/2014/01/20/google-java-style/",target:"_blank",rel:"noopener noreferrer"},v=o('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h3 id="_1-1-术语说明" tabindex="-1"><a class="header-anchor" href="#_1-1-术语说明" aria-hidden="true">#</a> 1.1 术语说明</h3><p>在本文档中，除非另有说明：</p><ol><li>术语class可表示一个普通类，枚举类，接口或是annotation类型(<code>@interface</code>)</li><li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。 其他的术语说明会偶尔在后面的文档出现。</li></ol><h3 id="_1-2-指南说明" tabindex="-1"><a class="header-anchor" href="#_1-2-指南说明" aria-hidden="true">#</a> 1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p><h2 id="源文件基础" tabindex="-1"><a class="header-anchor" href="#源文件基础" aria-hidden="true">#</a> 源文件基础</h2><h3 id="_2-1-文件名" tabindex="-1"><a class="header-anchor" href="#_2-1-文件名" aria-hidden="true">#</a> 2.1 文件名</h3><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p><h3 id="_2-2-文件编码-utf-8" tabindex="-1"><a class="header-anchor" href="#_2-2-文件编码-utf-8" aria-hidden="true">#</a> 2.2 文件编码：UTF-8</h3><p>源文件编码格式为UTF-8。</p><h3 id="_2-3-特殊字符" tabindex="-1"><a class="header-anchor" href="#_2-3-特殊字符" aria-hidden="true">#</a> 2.3 特殊字符</h3><h4 id="_2-3-1-空白字符" tabindex="-1"><a class="header-anchor" href="#_2-3-1-空白字符" aria-hidden="true">#</a> 2.3.1 空白字符</h4><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p><ol><li>所有其它字符串中的空白字符都要进行转义。</li><li>制表符不用于缩进。</li></ol>',17),b=a("div",{class:"custom-container warning"},[a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8v4"}),a("path",{d:"M12 16h.01"})])]),a("p",{class:"custom-container-title"},"WARNING"),a("p",null,"此处有疑问")],-1),g=a("h4",{id:"_2-3-2-特殊转义序列",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_2-3-2-特殊转义序列","aria-hidden":"true"},"#"),n(" 2.3.2 特殊转义序列")],-1),f={href:"https://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97",target:"_blank",rel:"noopener noreferrer"},x=o(`<h4 id="_2-3-3-非ascii字符" tabindex="-1"><a class="header-anchor" href="#_2-3-3-非ascii字符" aria-hidden="true">#</a> 2.3.3 非ASCII字符</h4><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\\u221e)，取决于哪个能让代码更易于阅读和理解。</p><blockquote><p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p></blockquote><p>例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> unitAbbrev <span class="token operator">=</span> <span class="token string">&quot;μs&quot;</span><span class="token punctuation">;</span>                                <span class="token comment">// 赞，即使没有注释也非常清晰</span>
<span class="token class-name">String</span> unitAbbrev <span class="token operator">=</span> <span class="token string">&quot;\\u03bcs&quot;</span><span class="token punctuation">;</span> <span class="token comment">// &quot;μs&quot;                   // 允许，但没有理由要这样做</span>
<span class="token class-name">String</span> unitAbbrev <span class="token operator">=</span> <span class="token string">&quot;\\u03bcs&quot;</span><span class="token punctuation">;</span> <span class="token comment">// Greek letter mu, &quot;s&quot;   // 允许，但这样做显得笨拙还容易出错</span>
<span class="token class-name">String</span> unitAbbrev <span class="token operator">=</span> <span class="token string">&quot;\\u03bcs&quot;</span><span class="token punctuation">;</span>                           <span class="token comment">// 很糟，读者根本看不出这是什么</span>
<span class="token keyword">return</span> <span class="token char">&#39;\\ufeff&#39;</span> <span class="token operator">+</span> content<span class="token punctuation">;</span> <span class="token comment">// byte order mark            // Good，对于非打印字符，使用转义，并在必要时写上注释</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p></blockquote><h2 id="源文件结构" tabindex="-1"><a class="header-anchor" href="#源文件结构" aria-hidden="true">#</a> 源文件结构</h2><p>一个源文件包含(按顺序地)：</p><ol><li>许可证或版权信息(如有需要)</li><li>package语句</li><li>import语句</li><li>一个顶级类(只有一个)</li></ol><p>以上每个部分之间用一个空行隔开。</p><h3 id="_3-1-许可证或版权信息" tabindex="-1"><a class="header-anchor" href="#_3-1-许可证或版权信息" aria-hidden="true">#</a> 3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="_3-2-package语句" tabindex="-1"><a class="header-anchor" href="#_3-2-package语句" aria-hidden="true">#</a> 3.2 package语句</h3><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p><h3 id="_3-3-import语句" tabindex="-1"><a class="header-anchor" href="#_3-3-import语句" aria-hidden="true">#</a> 3.3 import语句</h3><h4 id="_3-3-1-import不要使用通配符" tabindex="-1"><a class="header-anchor" href="#_3-3-1-import不要使用通配符" aria-hidden="true">#</a> 3.3.1 import不要使用通配符</h4><p>即，不要出现类似这样的import语句：<code>import java.util.*</code>;</p><h4 id="_3-3-2-不要换行" tabindex="-1"><a class="header-anchor" href="#_3-3-2-不要换行" aria-hidden="true">#</a> 3.3.2 不要换行</h4><p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p><h4 id="_3-3-3-顺序和间距" tabindex="-1"><a class="header-anchor" href="#_3-3-3-顺序和间距" aria-hidden="true">#</a> 3.3.3 顺序和间距</h4><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p><ol><li>所有的静态导入独立成组</li><li><code>com.google</code> imports(仅当这个源文件是在<code>com.google</code>包下)</li><li>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun</li><li><code>java</code> imports</li><li><code>javax</code> imports</li></ol><p>组内不空行，按字典序排列。</p><h3 id="_3-4-类声明" tabindex="-1"><a class="header-anchor" href="#_3-4-类声明" aria-hidden="true">#</a> 3.4 类声明</h3><h4 id="_3-4-1-只有一个顶级类声明" tabindex="-1"><a class="header-anchor" href="#_3-4-1-只有一个顶级类声明" aria-hidden="true">#</a> 3.4.1 只有一个顶级类声明</h4><p>每个顶级类都在一个与它同名的源文件中(当然，还包含<code>.java</code>后缀)。</p><p>例外：<code>package-info.java</code>，该文件中可没有<code>package-info</code>类。</p><h4 id="_3-4-2-类成员顺序" tabindex="-1"><a class="header-anchor" href="#_3-4-2-类成员顺序" aria-hidden="true">#</a> 3.4.2 类成员顺序</h4><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h5 id="_3-4-2-1-重载-永不分离" tabindex="-1"><a class="header-anchor" href="#_3-4-2-1-重载-永不分离" aria-hidden="true">#</a> 3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p><h2 id="格式" tabindex="-1"><a class="header-anchor" href="#格式" aria-hidden="true">#</a> 格式</h2><p><b>术语说明</b>：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p><h3 id="_4-1-大括号" tabindex="-1"><a class="header-anchor" href="#_4-1-大括号" aria-hidden="true">#</a> 4.1 大括号</h3><h4 id="_4-1-1-使用大括号-即使是可选的" tabindex="-1"><a class="header-anchor" href="#_4-1-1-使用大括号-即使是可选的" aria-hidden="true">#</a> 4.1.1 使用大括号(即使是可选的)</h4><p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="_4-1-2-非空块-k-r-风格" tabindex="-1"><a class="header-anchor" href="#_4-1-2-非空块-k-r-风格" aria-hidden="true">#</a> 4.1.2 非空块：K &amp; R 风格</h4>`,37),w={href:"http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html",target:"_blank",rel:"noopener noreferrer"},j=o(`<ul><li>除了下面详细说明的情况外，在左大括号之前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li></ul><p>示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ProblemException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.8.1节给出了enum类的一些例外。</p><h3 id="_4-1-3-空块-可以用简洁版本" tabindex="-1"><a class="header-anchor" href="#_4-1-3-空块-可以用简洁版本" aria-hidden="true">#</a> 4.1.3 空块：可以用简洁版本</h3><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。</p><p>示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_4-2-块缩进-2个空格" tabindex="-1"><a class="header-anchor" href="#_4-2-块缩进-2个空格" aria-hidden="true">#</a> 4.2 块缩进：2个空格</h3><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p><h3 id="_4-3-一行一个语句" tabindex="-1"><a class="header-anchor" href="#_4-3-一行一个语句" aria-hidden="true">#</a> 4.3 一行一个语句</h3><p>每个语句后要换行。</p><h3 id="_4-4-列限制-80或100" tabindex="-1"><a class="header-anchor" href="#_4-4-列限制-80或100" aria-hidden="true">#</a> 4.4 列限制：80或100</h3><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述的例外，任何一行如果超过这个字符数限制，必须自动换行。</p><p>例外：</p><ol><li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li><li>package和import语句(见3.2节和3.3节)。</li><li>注释中那些可能被剪切并粘贴到shell中的命令行。</li></ol><h3 id="_4-5-自动换行" tabindex="-1"><a class="header-anchor" href="#_4-5-自动换行" aria-hidden="true">#</a> 4.5 自动换行</h3><p><b>术语说明</b>：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p><p>我们并没有全面、确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p><blockquote><p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p></blockquote><h4 id="_4-5-1-从哪里断开" tabindex="-1"><a class="header-anchor" href="#_4-5-1-从哪里断开" aria-hidden="true">#</a> 4.5.1 从哪里断开</h4><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p><ol><li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 <ul><li>这条规则也适用于以下“类运算符”符号： <ul><li>点分隔符(<code>.</code>)</li><li>方法引用的两个冒号(<code>::</code>)</li><li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)</li><li>catch块中的管道符号(<code>catch (FooException | BarException e)</code>)</li></ul></li></ul></li><li>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。 方法名或构造函数名与左括号留在同一行。 逗号(,)与其前面的内容留在同一行。</li></ol>`,23),y={class:"custom-container warning"},q=a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8v4"}),a("path",{d:"M12 16h.01"})])],-1),I=a("p",{class:"custom-container-title"},"WARNING",-1),A=a("p",null,"这里参考译文跟原文很不一样，可能是原文有修改",-1),C={href:"https://google.github.io/styleguide/javaguide.html#s4.5.1-line-wrapping-where-to-break",target:"_blank",rel:"noopener noreferrer"};function S(B,E){const e=i("ExternalLinkIcon");return c(),r("div",null,[a("div",p,[d,h,a("p",null,[n("学习Google编程规范"),u,a("a",k,[n("原文链接"),s(e)]),_,a("a",m,[n("参考译文链接"),s(e)])])]),v,b,g,a("p",null,[n(`对于具有特殊转义序列的任何字符(\\b, \\t, \\n, \\f, \\r, ", '及)，我们使用它的`),a("a",f,[n("转义序列"),s(e)]),n("，而不是相应的八进制(比如\\012)或Unicode(比如\\u000a)转义。")]),x,a("p",null,[n("对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 ("),a("a",w,[n('"Egyptian brackets"'),s(e)]),n("):")]),j,a("div",y,[q,I,A,a("p",null,[n("放个"),a("a",C,[n("原文链接"),s(e)])])])])}const G=t(l,[["render",S],["__file","google_coding_style.html.vue"]]);export{G as default};
